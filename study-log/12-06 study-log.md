# JavaScript & TypeScript 강의

- **Background**
    
    ## 호이스팅(Hoisting)
    
    ---
    
    [MDN 문서](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)를 살펴보면 다음과 같이 설명하고 있습니다.
    
    *JavaScript에서 **호이스팅**(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다.*
    
    *호이스팅을 설명할 땐 주로 "변수의 **선언과 초기화를 분리**한 후, **선언만 코드의 최상단으로** 옮기는" 것으로 말하곤 합니다. 따라서 변수를 정의하는 코드보다 사용하는 코드가 앞서 등장할 수 있습니다. 다만 선언과 초기화를 함께 수행하는 경우, 선언 코드까지 실행해야 변수가 초기화된 상태가 됨을 주의하세요.*
    
    ⚠️ **let**, **const** vs **var**
    
    var 로 선언된 변수의 경우에는 undefined로 초기화하지만
    
    let, const로 선언된 변수의 경우는 초기화 되지 않기 때문에 [ReferenceError](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)를 발생시킨다.
    
    ## 컴파일러(Compiler)와 인터프리터(Interpreter)
    
    ---
    
    구글 서칭한 글 중 가장 도움이 되었던 글: [링크](https://soooprmx.com/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0%EC%96%B8%EC%96%B4%EC%9E%85%EB%8B%88%EA%B9%8C/)
    
    컴파일러와 인터프리터 모두 하나의 목적을 가지고 있는데, 개발자가 작성한 소스코드를 해당하는 환경에서 실행가능한 프로그램으로 변환하는 것이다.
    
    두가지를 구분하는 기준으로는 시점과 단위라고 생각해 볼 수 있다.
    
    **컴파일러**는 소스코드 **전체**를 실행(Runtime)**전**에 특정된 실행환경(때문에 빌드 관련 설정이 필요하다)의 기계어로 변환시킨다.
    
    **인터프리터**는 소스코드를 실행(Runtime)**될 때**, **명령어** 단위로 해당 환경의 기계어로 변환시킨다.
    
    대표적으로 컴파일러를 활용하는 언어는 C언어다.
    
    C언어는 소스코드를 사용자가 실행가능한 파일로 만드는 과정에 두가지 단계를 가진다.
    
    첫번째는 컴파일이(gcc -c)고 두번째는 링크(gcc -o)이다.
    
    이렇게 단계가 두가지로 나눈 것에는 여러가지가 있겠지만, 가장 중요한 이점은 모듈 스펙을 위해서이다.
    
    개별적으로 개발된 소스코드를 다른 소스코드에서 참조하여 사용하고 이때 형성되는 심볼간의 관계를 정리하는 역할이 두번째 단계에서 링커(linker)가 하는 일이다.
    
    인터프리터를 사용하는 언어도 여러가지가 있다.
    
    파이썬, 자바, 자바스크립트 등 여러가지 언어들이 소스코드를 기계어로 번환하는 과정에서 인터프리터 방식을 사용한다.
    
    현대적인 고급언어들의 구현 방식은 서두에 말한것처럼 소스코드에서 기계어로 바로 처리하진 않는다. 실행환경에 대한 유연성과 프로그램 자체의 퍼포먼스를 위해 하나의 레이어를 더 가져서,
    
    <aside>
    🐳 소스코드 → 바이트코드 → 기계어
    
    </aside>
    
    의 흐름을 가지게 된다.
    
    소스코드 → 바이트 코드의 변환은 각 언어의 **컴파일러**가 수행하고,
    
    바이트코드에서 기계어로 바꾸는 과정을 **인터프리터**가 수행하게 되는데, 각 언어의 인터프리터역할은 Virtual Machine(예를들어 Java의 JVM)과 같은 것들이 담당한다.
    
- **강의 내용 정리**
    
    ## 타입 별칭(Type Alias) & 인터페이스(Interface)
    
    ---
    
    기본적인 기능은 비슷하지만 약간의 차이점과 유의할 사항이 있다.
    
    | 차이점 | Type Alias | Interface |
    | --- | --- | --- |
    | [1] 중복된 선언 | 에러 발생 | 앞서 정의된 인터페이스 객체에 속성이 추가된다 |
    | [2] 타입 할당(assign) | 가능하다 | 불가능하다 |
    
    ### 각각 언제 사용하면 좋을까?
    
    ### Type Alias
    
    **데이터 종류를 표현할 타입**을 설정할 경우 사용하면 좋다.
    
    아래와 같은 방법으로 사용하는 경우이다.
    
    ```jsx
    type Name = string;
    let myName: Name = 'SleepyCloud';
    ```
    
    ### Interface
    
    인터페이스의 위의 경우와 같이 활용할 수 는 없다.
    
    클래스처럼 데이터와 행위가 모두 필요한 경우에 사용하면 좋다.
    
    ## 디렉토리 캡슐화
    
    ---
    
    참조할 객체가 있는 코드의 디렉토리 내부에 index.ts 파일을 추가하고
    
    ```jsx
    // export 지시어만으로 지정된 variable의 경우
    export { class_1, class_2, object } from `모듈 경로`
    // default export 지시어로 지정된 variable의 경우
    export { default as customName } from `모듈 경로`
    ```
    
    위와 같은 문법으로 작성하고,
    
    호출하여 코드에서는
    
    ```jsx
    import ${변수 이름***}*** from ***${모듈 디렉토리/모듈}***
    ```
    
    위와 같은 문법으로 참조하여 사용할 수 있다.
    
    index.ts 파일을 import 하는 경우 이름을 생략할 수 있어 모듈 디렉토리만 적어도 된다.
    
    사용하는 쪽에서 해당 디렉토리에 존재하는 모듈간의 계층구조를 신경 쓸 필요가 없기 때문에 사용한다. (인터페이스 제공으로 사용자 배려)
    
    ## 윈도우(window) 객체를 이용한 전역 변수
    
    ---
    
    window는 JS 코드 어디에서나 접근 가능한 **전역 객체**이다.
    
    특정 속성을 추가하여 전역 변수처럼 사용 가능하지만, 좋은 방법은 아니다. 
    
    Namespace의 충돌 가능이 존재한다.
    
    1. JavaScript: Dot(.) 을 이용하여 직접적으로 속성을 추가할 수 있다.
        
        ```jsx
        window.${myValue} = '원하는 데이터';
        ```
        
    2. TypeScript: 약간 복잡한 방법을 통해 이용가능하다.
        
        ```tsx
        declare global {
        	interface Window{
        		myValue: MyValueType;	
        	}
        }
        
        window.myValue = '원하는 데이터';
        ```
        
    
    **단점**
    
    실수로 잘못된 데이터를 세팅하거나 덮어쓰기되는 경우 
    
    완전히 의도하지 않은 방식으로 문제가 발생하고 
    
    그 문제가 어디에서 발생했는지 찾는 일 또한 매우 힘들다.